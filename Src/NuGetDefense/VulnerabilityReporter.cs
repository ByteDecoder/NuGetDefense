using System.Collections.Generic;
using System.Linq;
using System.Text;
using NuGetDefense.Core;

namespace NuGetDefense
{
    public class VulnerabilityReporter
    {
        private readonly bool _separateMsBuildMessages;
        public List<string> MsBuildMessages;
        public VulnerabilityReport Report;
        public string VulnerabilityTextReport;

        public VulnerabilityReporter(bool separateMsBuildMessages = true)
        {
            _separateMsBuildMessages = separateMsBuildMessages;
            if (separateMsBuildMessages) MsBuildMessages = new List<string>();
        }

        /// <summary>
        ///     Builds an object used for the various reporting methods
        /// </summary>
        /// <param name="vulnerabilityDictionary"></param>
        /// <param name="pkgs">Parsed Packages</param>
        /// <param name="nuGetFile">Either the project or packages file</param>
        /// <param name="warnOnly">If True, suppresses all errors</param>
        /// <param name="cvss3Threshold">Threshold CVSS score for error suppresion</param>
        public void BuildVulnerabilityReport(
            Dictionary<string, Dictionary<string, Vulnerability>> vulnerabilityDictionary,
            IEnumerable<NuGetPackage> pkgs, string nuGetFile, bool warnOnly, double cvss3Threshold)
        {
            Report = new VulnerabilityReport();
            Report.VulnerabilitiesCount = vulnerabilityDictionary.Sum(x => x.Value.Count);
            var nuGetPackages = pkgs as NuGetPackage[] ?? pkgs.ToArray();
            Report.Packages = nuGetPackages.Where(p =>
                p.LineNumber != null && vulnerabilityDictionary.ContainsKey(p.Id.ToLower())).Select(p => new VulnerableNuGetPackage {Id = p.Id, Version = p.Version}).ToArray();

            foreach (var pkg in nuGetPackages.Where(p =>
                p.LineNumber != null && vulnerabilityDictionary.ContainsKey(p.Id.ToLower())))
            {
                var vulnerabilities = vulnerabilityDictionary[pkg.Id.ToLower()];
                Report.Packages.Where(p => p.Id.ToLower() == pkg.Id.ToLower()).First()
                    .Vulnerabilities = vulnerabilities.Select(v => new ReportedVulnerability
                {
                    Description = v.Value.Description,
                    Cve = v.Value.Cve,
                    Cwe = v.Value.Cwe,
                    CvssScore = v.Value.CvssScore,
                    CvssVector = v.Value.Vector.ToString()
                }).ToArray();
            }
        }

        public void BuildVulnerabilityTextReport(
            Dictionary<string, Dictionary<string, Vulnerability>> vulnerabilityDictionary,
            IEnumerable<NuGetPackage> pkgs, string nuGetFile, bool warnOnly, double cvss3Threshold)
        {
            var logBuilder = new StringBuilder();
            var nuGetPackages = pkgs as NuGetPackage[] ?? pkgs.ToArray();
            logBuilder.AppendLine($"{vulnerabilityDictionary.Sum(ve => ve.Value.Count)} vulnerabilities found in {nuGetPackages.Count()} packages.");
            foreach (var pkg in nuGetPackages.Where(p =>
                p.LineNumber != null && vulnerabilityDictionary.ContainsKey(p.Id.ToLower())))
            {
                var vulnerabilities = vulnerabilityDictionary[pkg.Id.ToLower()];


                logBuilder.AppendLine("*************************************");
                warnOnly = warnOnly ||
                           !vulnerabilities.Any(v => v.Value.CvssScore >= cvss3Threshold);
                var dependantVulnerabilities = pkg.Dependencies.Where(dep => vulnerabilityDictionary.ContainsKey(dep));

                var vulnTotalMSbuildMessage = MsBuild.Log(nuGetFile, warnOnly ? MsBuild.Category.Warning : MsBuild.Category.Error, pkg.LineNumber, pkg.LinePosition,
                    $"{vulnerabilities.Count} vulnerabilities found for {pkg.Id} @ {pkg.Version}");
                
                if(vulnerabilities.Any())
                {
                    if (_separateMsBuildMessages) MsBuildMessages.Add(vulnTotalMSbuildMessage);
                    else logBuilder.AppendLine(vulnTotalMSbuildMessage);
                }

                var dependancies = dependantVulnerabilities as string[] ?? dependantVulnerabilities.ToArray();
                if (dependancies.Any())
                {
                    var dependantVulnTotalMsBuildMessage = MsBuild.Log(nuGetFile, warnOnly ? MsBuild.Category.Warning : MsBuild.Category.Error, pkg.LineNumber, pkg.LinePosition,
                        $"{dependancies.Count()} vulnerabilities found for dependencies of {pkg.Id} @ {pkg.Version}");

                    if (_separateMsBuildMessages) MsBuildMessages.Add(dependantVulnTotalMsBuildMessage);
                    else logBuilder.AppendLine(dependantVulnTotalMsBuildMessage);
                }

                foreach (var cve in vulnerabilities.Keys)
                {
                    warnOnly = warnOnly || vulnerabilities[cve].CvssScore <= cvss3Threshold && vulnerabilities[cve].CvssScore > -1;

                    var vulnMsBuildMessage = MsBuild.Log(nuGetFile, warnOnly ? MsBuild.Category.Warning : MsBuild.Category.Error, cve, pkg.LineNumber, pkg.LinePosition,
                        $"{vulnerabilities[cve].Description}");

                    if (_separateMsBuildMessages) MsBuildMessages.Add(vulnMsBuildMessage);
                    else logBuilder.AppendLine(vulnMsBuildMessage);

                    logBuilder.AppendLine($"Description: {vulnerabilities[cve].Description}");
                    logBuilder.AppendLine($"CVE: {cve}");
                    logBuilder.AppendLine($"CWE: {vulnerabilities[cve].Cwe}");
                    logBuilder.AppendLine($"CVSS Score: {vulnerabilities[cve].CvssScore}");
                    logBuilder.AppendLine($"CVSS Vector: {vulnerabilities[cve].Vector}");
                    if (vulnerabilities[cve].References != null && vulnerabilities[cve].References.Any())
                    {
                        logBuilder.AppendLine("References:");
                        foreach (var reference in vulnerabilities[cve].References) logBuilder.AppendLine(reference);
                    }

                    logBuilder.AppendLine("---------------------------");
                }

                foreach (var dependancy in dependancies)
                {
                    vulnerabilities = vulnerabilityDictionary[dependancy];
                    foreach (var cve in vulnerabilities.Keys)
                    {
                        warnOnly = warnOnly ||
                                   vulnerabilities[cve].CvssScore <= cvss3Threshold;

                        var vulnMsBuildMessage = MsBuild.Log(nuGetFile, warnOnly ? MsBuild.Category.Warning : MsBuild.Category.Error, cve, pkg.LineNumber, pkg.LinePosition,
                            $"{dependancy}: {vulnerabilities[cve].Description}");

                        if (_separateMsBuildMessages) MsBuildMessages.Add(vulnMsBuildMessage);
                        else logBuilder.AppendLine(vulnMsBuildMessage);
                        logBuilder.AppendLine($"Description: {vulnerabilities[cve].Description}");
                        logBuilder.AppendLine($"CVE: {cve}");
                        logBuilder.AppendLine($"CWE: {vulnerabilities[cve].Cwe}");
                        logBuilder.AppendLine($"CVSS Score: {vulnerabilities[cve].CvssScore}");
                        logBuilder.AppendLine($"CVSS Vector: {vulnerabilities[cve].Vector}");
                        // if (vulnerabilities[cve].Version?.Length > 0)
                        //     logBuilder.AppendLine($"Affected Version: {vulnerabilities[cve].Version}");
                        logBuilder.AppendLine("---------------------------");
                    }
                }
            }

            VulnerabilityTextReport = logBuilder.ToString();
        }
    }
}